
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent_server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">parallel-calculator/cmd/agent_server/main.go (0.0%)</option>
				
				<option value="file1">parallel-calculator/cmd/orchestrator_server/main.go (0.0%)</option>
				
				<option value="file2">parallel-calculator/internal/agent/agent.go (1.9%)</option>
				
				<option value="file3">parallel-calculator/internal/agent/worker.go (81.8%)</option>
				
				<option value="file4">parallel-calculator/internal/auth/auth.go (90.9%)</option>
				
				<option value="file5">parallel-calculator/internal/auth/handlers.go (76.5%)</option>
				
				<option value="file6">parallel-calculator/internal/auth/middleware.go (100.0%)</option>
				
				<option value="file7">parallel-calculator/internal/config/config.go (0.0%)</option>
				
				<option value="file8">parallel-calculator/internal/db/db.go (41.7%)</option>
				
				<option value="file9">parallel-calculator/internal/db/expressions.go (78.9%)</option>
				
				<option value="file10">parallel-calculator/internal/db/operations.go (80.8%)</option>
				
				<option value="file11">parallel-calculator/internal/db/users.go (84.3%)</option>
				
				<option value="file12">parallel-calculator/internal/grpc/client.go (69.7%)</option>
				
				<option value="file13">parallel-calculator/internal/grpc/server.go (75.0%)</option>
				
				<option value="file14">parallel-calculator/internal/logger/logger.go (0.0%)</option>
				
				<option value="file15">parallel-calculator/internal/orchestrator/ast_parser.go (72.7%)</option>
				
				<option value="file16">parallel-calculator/internal/orchestrator/db_integration.go (73.3%)</option>
				
				<option value="file17">parallel-calculator/internal/orchestrator/endpoints.go (76.6%)</option>
				
				<option value="file18">parallel-calculator/internal/orchestrator/orchestrator.go (70.0%)</option>
				
				<option value="file19">parallel-calculator/proto/task.pb.go (0.0%)</option>
				
				<option value="file20">parallel-calculator/proto/task_grpc.pb.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "parallel-calculator/internal/agent"
        "parallel-calculator/internal/config"
        "parallel-calculator/internal/logger"
)

func main() <span class="cov0" title="0">{
        config.InitConfig(".env")
        logger.InitAgentLogger()
        defer logger.CloseLogger()

        logger.INFO.Println("Agent server started")
        defer logger.INFO.Println("Agent server stopped")

        agent.StartAgent()
}</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "parallel-calculator/internal/auth"
        "parallel-calculator/internal/config"
        "parallel-calculator/internal/db"
        "parallel-calculator/internal/grpc"
        "parallel-calculator/internal/logger"
        "parallel-calculator/internal/orchestrator"
        "strconv"
        "syscall"

        "github.com/gorilla/mux"
)

func main() <span class="cov0" title="0">{
        config.InitConfig(".env")
        logger.InitClientLogger()
        defer logger.CloseLogger()

        // Инициализируем базу данных
        err := db.InitDB("internal/db/")
        if err != nil </span><span class="cov0" title="0">{
                logger.ERROR.Fatalf("Ошибка инициализации базы данных: %v", err)
        }</span>

        // Настраиваем HTTP сервер
        <span class="cov0" title="0">r := mux.NewRouter()

        // Публичные эндпоинты для аутентификации
        r.HandleFunc("/api/v1/register", auth.Register).Methods("POST")
        r.HandleFunc("/api/v1/login", auth.Login).Methods("POST")

        // Защищенные маршруты для пользовательского API
        protected := r.PathPrefix("/api/v1").Subrouter()
        protected.Use(auth.AuthMiddleware)
        protected.HandleFunc("/calculate", orchestrator.HandleCalculate).Methods("POST")
        protected.HandleFunc("/expressions", orchestrator.HandleGetExpressions).Methods("GET")
        protected.HandleFunc("/expressions/{id}", orchestrator.HandleGetExpressionByID).Methods("GET")

        // Запускаем HTTP сервер в отдельной горутине
        httpServer := &amp;http.Server{
                Addr:    ":" + config.AppConfig.ServerPort,
                Handler: r,
        }

        go func() </span><span class="cov0" title="0">{
                logger.INFO.Println("HTTP сервер запущен на порту " + config.AppConfig.ServerPort)
                if err := httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.ERROR.Fatalf("Ошибка запуска HTTP сервера: %v", err)
                }</span>
        }()

        // Запускаем gRPC сервер в отдельной горутине
        // Используем порт HTTP + 1 для gRPC
        <span class="cov0" title="0">httpPort, _ := strconv.Atoi(config.AppConfig.ServerPort)
        grpcPort := fmt.Sprintf("%d", httpPort+1)
        grpcAddress := ":" + grpcPort

        // Используем обновленную сигнатуру, но игнорируем возвращаемый сервер
        _, err = grpc.StartGRPCServer(grpcAddress)
        if err != nil </span><span class="cov0" title="0">{
                logger.ERROR.Fatalf("Ошибка запуска gRPC сервера: %v", err)
        }</span>
        <span class="cov0" title="0">logger.INFO.Println("gRPC сервер запущен на порту " + grpcPort)

        // Ожидаем сигнал для остановки
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)
        &lt;-sigCh

        logger.INFO.Println("Получен сигнал остановки, завершаем работу серверов...")
        logger.INFO.Println("Оркестратор остановлен")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package agent

import (
        "fmt"
        "parallel-calculator/internal/config"
        "parallel-calculator/internal/grpc"
        "parallel-calculator/internal/logger"
        "strconv"
        "time"
)

// TaskClient представляет интерфейс для клиента, который взаимодействует с оркестратором
type TaskClient interface {
        // GetTask получает задачу от оркестратора
        GetTask() (*Task, error)
        // SendTaskResult отправляет результат задачи оркестратору
        SendTaskResult(TaskResult) error
        // Close закрывает соединение с оркестратором
        Close() error
}

// grpcClientAdapter адаптирует GRPCTaskClient к интерфейсу TaskClient
type grpcClientAdapter struct {
        address string
        client  *grpc.GRPCTaskClient
}

// NewGRPCClient создает новый gRPC клиент для оркестратора
func NewGRPCClient(address string) (TaskClient, error) <span class="cov8" title="1">{
        return &amp;grpcClientAdapter{address: address}, nil
}</span>

// Инициализация клиента при первом использовании
func (g *grpcClientAdapter) ensureClient() error <span class="cov0" title="0">{
        if g.client == nil </span><span class="cov0" title="0">{
                var err error
                g.client, err = grpc.NewGRPCTaskClient(g.address)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetTask получает задачу через gRPC
func (g *grpcClientAdapter) GetTask() (*Task, error) <span class="cov0" title="0">{
        if err := g.ensureClient(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Получаем задачу из gRPC
        <span class="cov0" title="0">grpcTask, err := g.client.GetTask()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Если нет задачи, возвращаем nil
        <span class="cov0" title="0">if grpcTask == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        
        // Преобразуем в локальный тип Task
        <span class="cov0" title="0">return &amp;Task{
                ID:            grpcTask.ID,
                LeftValue:     grpcTask.LeftValue,
                RightValue:    grpcTask.RightValue,
                Operator:      grpcTask.Operator,
                OperationTime: grpcTask.OperationTime,
        }, nil</span>
}

// SendTaskResult отправляет результат задачи через gRPC
func (g *grpcClientAdapter) SendTaskResult(result TaskResult) error <span class="cov0" title="0">{
        if err := g.ensureClient(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Преобразуем в тип для gRPC
        <span class="cov0" title="0">grpcResult := grpc.TaskResult{
                ID:     result.ID,
                Result: result.Result,
                Error:  result.Error,
        }
        
        return g.client.SendTaskResult(grpcResult)</span>
}

// Close закрывает соединение
func (g *grpcClientAdapter) Close() error <span class="cov0" title="0">{
        if g.client != nil </span><span class="cov0" title="0">{
                return g.client.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Оставляем только gRPC реализацию

// StartAgent инициализирует и запускает агента с заданным количеством воркеров,
// которые получают задачи от оркестратора и выполняют их параллельно
func StartAgent() <span class="cov0" title="0">{
        cp := config.AppConfig.ComputingPower
        // Исправлено дублирование условия
        if cp == 0 </span><span class="cov0" title="0">{
                logger.ERROR.Println("COMPUTING_POWER is 0. AUTO SET TO 1")
                cp = 1
        }</span>

        <span class="cov0" title="0">logger.INFO.Println("COMPUTING_POWER set to", cp)
        logger.INFO.Println("Starting workers...")

        tasks_chan := make(chan Task, cp)
        for i := 0; i &lt; cp; i++ </span><span class="cov0" title="0">{
                go Worker(tasks_chan, i+1)
        }</span>

        // Всегда используем gRPC
        <span class="cov0" title="0">logger.INFO.Println("Starting Agent with gRPC communication")

        // Создаем клиента gRPC
        var client TaskClient
        var err error

        // Создаем адрес для gRPC сервера (порт HTTP + 1)
        httpPort, _ := strconv.Atoi(config.AppConfig.OrchestratorPort)
        grpcPort := httpPort + 1
        grpcAddress := fmt.Sprintf("%s:%d", config.AppConfig.OrchestratorHost, grpcPort)

        logger.INFO.Printf("Connecting to gRPC server at %s", grpcAddress)
        client, err = NewGRPCClient(grpcAddress)
        if err != nil </span><span class="cov0" title="0">{
                logger.ERROR.Fatalf("Failed to create gRPC client: %v - terminating agent", err)
        }</span>
        // Закрываем клиент при завершении
        <span class="cov0" title="0">defer client.Close()

        // Устанавливаем глобального клиента для использования рабочими потоками
        SetGlobalClient(client)

        for </span><span class="cov0" title="0">{
                time.Sleep(config.AppConfig.AgentRequestTimeout)
                
                // Получаем задачу через выбранный клиент
                task, err := client.GetTask()

                if err != nil </span><span class="cov0" title="0">{
                        logger.ERROR.Println(err)
                        // Не завершаем агента, просто продолжаем работу
                        continue</span>
                }
                <span class="cov0" title="0">if task == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">tasks_chan &lt;- *task</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package agent

import (
        "parallel-calculator/internal/logger"
        "time"
)

// Глобальный клиент gRPC для работы с оркестратором
var globalClient TaskClient

// Устанавливает глобального клиента для использования рабочими потоками
func SetGlobalClient(client TaskClient) <span class="cov8" title="1">{
        globalClient = client
}</span>

// Worker обрабатывает поступающие задачи из канала
func Worker(tasks_chan chan Task, worker_id int) <span class="cov8" title="1">{
        for task := range tasks_chan </span><span class="cov8" title="1">{
                logger.INFO.Println("Worker", worker_id, "received task: ", task)
                result := 0.0
                Error := "nil"

                switch task.Operator </span>{
                case "+":<span class="cov8" title="1">
                        result = task.LeftValue + task.RightValue</span>
                case "-":<span class="cov8" title="1">
                        result = task.LeftValue - task.RightValue</span>
                case "*":<span class="cov8" title="1">
                        result = task.LeftValue * task.RightValue</span>
                case "/":<span class="cov8" title="1">
                        if task.RightValue == 0 </span><span class="cov8" title="1">{
                                result = 0
                                Error = "division by zero"
                        }</span> else<span class="cov8" title="1"> {
                                result = task.LeftValue / task.RightValue
                        }</span>
                }
                <span class="cov8" title="1">time.Sleep(task.OperationTime)
                taskResult := TaskResult{
                        ID:     task.ID,
                        Result: result,
                        Error:  Error,
                }
                
                                if globalClient == nil </span><span class="cov0" title="0">{
                        logger.ERROR.Printf("Worker %d: глобальный клиент не установлен", worker_id)
                        return
                }</span>
                
                // gRPC клиенты потокобезопасны по умолчанию
                <span class="cov8" title="1">err := globalClient.SendTaskResult(taskResult)
                
                if err != nil </span><span class="cov0" title="0">{
                        logger.ERROR.Printf("Worker %d: ошибка отправки результата: %v", worker_id, err)
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "errors"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"

        "parallel-calculator/internal/config"
        "parallel-calculator/internal/db"
)

var (
        ErrInvalidToken      = errors.New("недействительный токен")
        ErrExpiredToken      = errors.New("истекший токен")
        ErrMissingAuthHeader = errors.New("отсутствует заголовок Authorization")
        ErrInvalidAuthHeader = errors.New("недействительный формат заголовка Authorization")
)

// Claims представляет собой утверждения JWT
type Claims struct {
        UserID int64  `json:"user_id"`
        Login  string `json:"login"`
        jwt.RegisteredClaims
}

// GenerateToken создает JWT токен для пользователя
func GenerateToken(user *db.User) (string, error) <span class="cov8" title="1">{
        // Время истечения токена из конфигурации
        expirationTime := time.Now().Add(time.Duration(config.AppConfig.JWTExpirationMinutes) * time.Minute)

        // Создаем утверждения с ID пользователя и временем истечения
        claims := &amp;Claims{
                UserID: user.ID,
                Login:  user.Login,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expirationTime),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
        }

        // Создаем токен с указанными утверждениями и подписываем его с помощью метода HS256
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        // Создаем строковое представление токена
        tokenString, err := token.SignedString([]byte(config.AppConfig.JWTSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return tokenString, nil</span>
}

// ValidateToken проверяет токен и возвращает утверждения, если токен действителен
func ValidateToken(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        // Парсим токен и проверяем его действительность
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                // Проверяем, что используется правильный алгоритм подписи
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("неожиданный метод подписи: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return []byte(config.AppConfig.JWTSecret), nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, jwt.ErrTokenExpired) </span><span class="cov8" title="1">{
                        return nil, ErrExpiredToken
                }</span>
                <span class="cov8" title="1">return nil, ErrInvalidToken</span>
        }

        // Извлекаем утверждения
        <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

// ExtractTokenFromHeader извлекает токен из заголовка Authorization
func ExtractTokenFromHeader(r *http.Request) (string, error) <span class="cov8" title="1">{
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" </span><span class="cov8" title="1">{
                return "", ErrMissingAuthHeader
        }</span>

        // Проверяем, начинается ли заголовок с "Bearer "
        <span class="cov8" title="1">parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov8" title="1">{
                return "", ErrInvalidAuthHeader
        }</span>

        <span class="cov8" title="1">return parts[1], nil</span>
}

// GetUserFromToken получает пользователя на основе токена
func GetUserFromToken(tokenString string) (*db.User, error) <span class="cov8" title="1">{
        claims, err := ValidateToken(tokenString)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">user, err := db.GetUserByID(claims.UserID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package auth

import (
        "encoding/json"
        "net/http"

        "parallel-calculator/internal/db"
)

// LoginRequest представляет запрос на вход
type LoginRequest struct {
        Login    string `json:"login"`
        Password string `json:"password"`
}

// RegisterRequest представляет запрос на регистрацию
type RegisterRequest struct {
        Login    string `json:"login"`
        Password string `json:"password"`
}

// AuthResponse представляет ответ на запрос аутентификации
type AuthResponse struct {
        Token string   `json:"token"`
        User  *db.User `json:"user"`
}

// Register обрабатывает запрос на регистрацию
func Register(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req RegisterRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка при разборе JSON: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        // Проверяем, что логин и пароль не пустые
        <span class="cov8" title="1">if req.Login == "" || req.Password == "" </span><span class="cov8" title="1">{
                http.Error(w, "Логин и пароль не могут быть пустыми", http.StatusBadRequest)
                return
        }</span>

        // Создаем пользователя
        <span class="cov8" title="1">_, err := db.CreateUser(req.Login, req.Password)
        if err != nil </span><span class="cov8" title="1">{
                if err == db.ErrUserAlreadyExists </span><span class="cov8" title="1">{
                        http.Error(w, "Пользователь с таким логином уже существует", http.StatusConflict)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Ошибка при создании пользователя: "+err.Error(), http.StatusInternalServerError)
                return</span>
        }

        // Устанавливаем статус 200 OK без дополнительного содержимого
        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}

// Login обрабатывает запрос на вход пользователя (POST /api/v1/login)
func Login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Ошибка при разборе JSON: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        // Проверяем учетные данные
        <span class="cov8" title="1">user, err := db.AuthenticateUser(req.Login, req.Password)
        if err != nil </span><span class="cov8" title="1">{
                if err == db.ErrUserNotFound || err == db.ErrInvalidCredentials </span><span class="cov8" title="1">{
                        http.Error(w, "Неверный логин или пароль", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Ошибка при аутентификации: "+err.Error(), http.StatusInternalServerError)
                return</span>
        }

        // Генерируем токен
        <span class="cov8" title="1">token, err := GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Ошибка при создании токена: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Формируем ответ с токеном
        <span class="cov8" title="1">resp := struct {
                Token string `json:"token"`
        }{
                Token: token,
        }

        // Устанавливаем заголовок Content-Type и статус 200 OK
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(resp)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

import (
        "context"
        "net/http"
)

// Ключ контекста для пользователя
type contextKey string

const UserContextKey contextKey = "user"

// AuthMiddleware проверяет JWT токен в заголовке Authorization
func AuthMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Извлекаем токен из заголовка
                tokenString, err := ExtractTokenFromHeader(r)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Не авторизован: "+err.Error(), http.StatusUnauthorized)
                        return
                }</span>

                // Проверяем токен
                <span class="cov8" title="1">claims, err := ValidateToken(tokenString)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Не авторизован: "+err.Error(), http.StatusUnauthorized)
                        return
                }</span>

                // Добавляем информацию о пользователе в контекст запроса
                <span class="cov8" title="1">ctx := context.WithValue(r.Context(), UserContextKey, claims)

                // Вызываем следующий обработчик с обновленным контекстом
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// GetUserFromContext извлекает пользовательские утверждения из контекста
func GetUserFromContext(ctx context.Context) (*Claims, bool) <span class="cov8" title="1">{
        claims, ok := ctx.Value(UserContextKey).(*Claims)
        return claims, ok
}</span>

// RequireAuth проверяет, аутентифицирован ли запрос, и возвращает ID пользователя
func RequireAuth(r *http.Request) (int64, error) <span class="cov8" title="1">{
        claims, ok := GetUserFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                return 0, ErrInvalidToken
        }</span>
        <span class="cov8" title="1">return claims.UserID, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "log"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/joho/godotenv"
)

type Config struct {
        AgentLogFilePath    string
        ClientLogFilePath   string
        ComputingPower      int
        TimeAddition        time.Duration
        TimeSubtraction     time.Duration
        TimeMultiplication  time.Duration
        TimeDivision        time.Duration
        AgentRequestTimeout time.Duration
        ServerPort          string
        OrchestratorBaseURL string
        // gRPC настройки
        OrchestratorHost   string // Хост оркестратора для gRPC
        OrchestratorPort   string // Порт оркестратора для HTTP
        // База данных и аутентификация
        DBPath              string
        JWTSecret           string
        JWTExpirationMinutes int
}

var (
        AppConfig *Config
        Once      sync.Once
)

func InitConfig(configPath string) <span class="cov0" title="0">{
        AppConfig = &amp;Config{}

        if _, err := os.Stat(configPath); err == nil </span><span class="cov0" title="0">{
                err := godotenv.Load(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Error loading .env file")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Println("/.env not found")
                // current path
                log.Println(os.Getwd())
        }</span>

        <span class="cov0" title="0">if os.Getenv("AGENT_LOG_FILE_PATH") != "" </span><span class="cov0" title="0">{
                AppConfig.AgentLogFilePath = os.Getenv("AGENT_LOG_FILE_PATH")
        }</span> else<span class="cov0" title="0"> {
                AppConfig.AgentLogFilePath = os.Getenv("AGENT_LOG_FILE_PATH")
        }</span>

        <span class="cov0" title="0">if os.Getenv("CLIENT_LOG_FILE_PATH") != "" </span><span class="cov0" title="0">{
                AppConfig.ClientLogFilePath = os.Getenv("CLIENT_LOG_FILE_PATH")
        }</span> else<span class="cov0" title="0"> {
                AppConfig.ClientLogFilePath = os.Getenv("CLIENT_LOG_FILE_PATH")
        }</span>

        <span class="cov0" title="0">if os.Getenv("COMPUTING_POWER") != "" </span><span class="cov0" title="0">{
                var err error
                AppConfig.ComputingPower, err = strconv.Atoi(os.Getenv("COMPUTING_POWER"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("COMPUTING_POWER not a number")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Fatal("COMPUTING_POWER not set")
        }</span>

        <span class="cov0" title="0">if os.Getenv("TIME_ADDITION_MS") != "" </span><span class="cov0" title="0">{
                value, err := strconv.Atoi(os.Getenv("TIME_ADDITION_MS"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("TIME_ADDITION_MS not a number")
                }</span>
                <span class="cov0" title="0">AppConfig.TimeAddition = time.Duration(value) * time.Millisecond</span>
        } else<span class="cov0" title="0"> {
                log.Fatal("TIME_ADDITION_MS not set")
        }</span>

        <span class="cov0" title="0">if os.Getenv("TIME_SUBTRACTION_MS") != "" </span><span class="cov0" title="0">{
                value, err := strconv.Atoi(os.Getenv("TIME_SUBTRACTION_MS"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("TIME_SUBTRACTION_MS not a number")
                }</span>
                <span class="cov0" title="0">AppConfig.TimeSubtraction = time.Duration(value) * time.Millisecond</span>
        } else<span class="cov0" title="0"> {
                log.Fatal("TIME_SUBTRACTION_MS not set")
        }</span>

        <span class="cov0" title="0">if os.Getenv("TIME_MULTIPLICATION_MS") != "" </span><span class="cov0" title="0">{
                value, err := strconv.Atoi(os.Getenv("TIME_MULTIPLICATION_MS"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("TIME_MULTIPLICATION_MS not a number")
                }</span>
                <span class="cov0" title="0">AppConfig.TimeMultiplication = time.Duration(value) * time.Millisecond</span>
        } else<span class="cov0" title="0"> {
                log.Fatal("TIME_MULTIPLICATION_MS not set")
        }</span>

        <span class="cov0" title="0">if os.Getenv("TIME_DIVISION_MS") != "" </span><span class="cov0" title="0">{
                value, err := strconv.Atoi(os.Getenv("TIME_DIVISION_MS"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("TIME_DIVISION_MS not a number")
                }</span>
                <span class="cov0" title="0">AppConfig.TimeDivision = time.Duration(value) * time.Millisecond</span>
        } else<span class="cov0" title="0"> {
                log.Fatal("TIME_DIVISION_MS not set")
        }</span>

        <span class="cov0" title="0">if os.Getenv("AGENT_REQUEST_TIMEOUT_MS") != "" </span><span class="cov0" title="0">{
                value, err := strconv.Atoi(os.Getenv("AGENT_REQUEST_TIMEOUT_MS"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("AGENT_REQUEST_TIMEOUT_MS not a number")
                }</span>
                <span class="cov0" title="0">AppConfig.AgentRequestTimeout = time.Duration(value) * time.Millisecond</span>
        } else<span class="cov0" title="0"> {
                log.Fatal("AGENT_REQUEST_TIMEOUT_MS not set")
        }</span>

        <span class="cov0" title="0">if os.Getenv("SERVER_PORT") != "" </span><span class="cov0" title="0">{
                AppConfig.ServerPort = os.Getenv("SERVER_PORT")
        }</span> else<span class="cov0" title="0"> {
                AppConfig.ServerPort = "8080"
        }</span>

        <span class="cov0" title="0">if os.Getenv("ORCHESTRATOR_BASE_URL") != "" </span><span class="cov0" title="0">{
                AppConfig.OrchestratorBaseURL = os.Getenv("ORCHESTRATOR_BASE_URL")
        }</span> else<span class="cov0" title="0"> {
                AppConfig.OrchestratorBaseURL = "http://localhost:8080"
        }</span>
        
        // gRPC настройки не нужно инициализировать, т.к. всегда используем gRPC
        
        // Вытаскиваем из OrchestratorBaseURL хост и порт
        // Предполагаем формат "http://host:port"
        <span class="cov0" title="0">baseURL := AppConfig.OrchestratorBaseURL
        // Удаляем "http://" или "https://"
        baseURL = baseURL[strings.Index(baseURL, "://")+3:]
        // Разделяем на хост и порт
        parts := strings.Split(baseURL, ":")
        if len(parts) &gt;= 1 </span><span class="cov0" title="0">{
                // Первая часть - хост
                AppConfig.OrchestratorHost = parts[0]
        }</span>
        <span class="cov0" title="0">if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                // Вторая часть - порт
                AppConfig.OrchestratorPort = parts[1]
        }</span> else<span class="cov0" title="0"> {
                // По умолчанию - 8080
                AppConfig.OrchestratorPort = "8080"
        }</span>

        // Инициализация параметров базы данных
        <span class="cov0" title="0">if os.Getenv("DB_PATH") != "" </span><span class="cov0" title="0">{
                AppConfig.DBPath = os.Getenv("DB_PATH")
        }</span> else<span class="cov0" title="0"> {
                AppConfig.DBPath = "./data/calculator.db"
                log.Println("Using default DB_PATH: ./data/calculator.db")
        }</span>

        <span class="cov0" title="0">if os.Getenv("JWT_SECRET") != "" </span><span class="cov0" title="0">{
                AppConfig.JWTSecret = os.Getenv("JWT_SECRET")
        }</span> else<span class="cov0" title="0"> {
                log.Println("WARNING: Using default JWT_SECRET. This is insecure for production!")
                AppConfig.JWTSecret = "your-secret-key-for-jwt-signing"
        }</span>

        // Срок действия JWT токена в часах
        <span class="cov0" title="0">if os.Getenv("JWT_EXPIRATION_MINUTES") != "" </span><span class="cov0" title="0">{
                expiration, err := strconv.Atoi(os.Getenv("JWT_EXPIRATION_MINUTES"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("WARNING: JWT_EXPIRATION_MINUTES not a valid number, using default value of 1440 minutes (24 hours)")
                        AppConfig.JWTExpirationMinutes = 1440
                }</span> else<span class="cov0" title="0"> {
                        AppConfig.JWTExpirationMinutes = expiration
                }</span>
        } else<span class="cov0" title="0"> {
                log.Println("JWT_EXPIRATION_MINUTES not set, using default value of 1440 minutes (24 hours)")
                AppConfig.JWTExpirationMinutes = 1440
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package db

import (
        "database/sql"
        "fmt"
        "os"
        "path/filepath"
        "sync"

        "parallel-calculator/internal/config"

        _ "github.com/mattn/go-sqlite3"
)

var (
        DB *sql.DB

        // Мьютекс для защиты параллельных операций с базой данных
        DbMutex sync.Mutex
)

// InitDB инициализирует соединение с базой данных SQLite
func InitDB(packagePath string) error <span class="cov0" title="0">{
        // Получаем путь к базе данных из конфигурации
        dbPath := config.AppConfig.DBPath

        // Проверка, что директория для базы данных существует
        dbDir := filepath.Dir(dbPath)
        if _, err := os.Stat(dbDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if err := os.MkdirAll(dbDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create database directory: %w", err)
                }</span>
        }

        <span class="cov0" title="0">var err error

        // Открываем соединение с базой данных
        DB, err = sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Проверяем соединение
        <span class="cov0" title="0">if err = DB.Ping(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">if err = ApplySchema(filepath.Join(packagePath, "schema.sql")); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply schema: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func CloseDB() error <span class="cov0" title="0">{
        if DB != nil </span><span class="cov0" title="0">{
                return DB.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CleanupDB очищает все таблицы в базе данных (используется для тестирования)
func CleanupDB() error <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()

        tables := []string{"operations", "expressions", "users"}

        for _, table := range tables </span><span class="cov8" title="1">{
                _, err := DB.Exec("DELETE FROM " + table)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clean up table %s: %w", table, err)
                }</span>
        }

        // Сбрасываем автоинкрементные счетчики
        <span class="cov8" title="1">for _, table := range tables </span><span class="cov8" title="1">{
                _, err := DB.Exec("DELETE FROM sqlite_sequence WHERE name=?", table)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reset auto-increment for table %s: %w", table, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// applySchema выполняет SQL из файла schema.sql
func ApplySchema(schemaPath string) error <span class="cov8" title="1">{

        schemaBytes, err := os.ReadFile(schemaPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read schema file: %w", err)
        }</span>

        <span class="cov8" title="1">_, err = DB.Exec(string(schemaBytes))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute schema: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package db

import (
        "database/sql"
        "errors"
        "time"
)

var (
        ErrExpressionNotFound = errors.New("expression not found")
)

// CreateExpression создает новое выражение в базе данных
func CreateExpression(userID int64, expression string) (*Expression, error) <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        res, err := DB.Exec(
                `INSERT INTO expressions (user_id, original_expression, status) VALUES (?, ?, ?)`,
                userID, expression, StatusPending,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">id, err := res.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;Expression{
                ID:         id,
                UserID:     userID,
                Expression: expression,
                Status:     StatusPending,
                CreatedAt:  time.Now(),
                UpdatedAt:  time.Now(),
        }, nil</span>
}

// GetExpressionByID получает выражение по ID
func GetExpressionByID(id int64) (*Expression, error) <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        var expr Expression
        var createdAtStr, updatedAtStr string
        var result sql.NullFloat64
        var errorMessage sql.NullString

        err := DB.QueryRow(
                `SELECT id, user_id, original_expression, status, result, 
         error_message, created_at, updated_at 
         FROM expressions WHERE id = ?`,
                id,
        ).Scan(
                &amp;expr.ID, &amp;expr.UserID, &amp;expr.Expression, &amp;expr.Status,
                &amp;result, &amp;errorMessage, &amp;createdAtStr, &amp;updatedAtStr,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrExpressionNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if result.Valid </span><span class="cov8" title="1">{
                val := result.Float64
                expr.Result = &amp;val
        }</span>

        <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov8" title="1">{
                val := errorMessage.String
                expr.ErrorMessage = &amp;val
        }</span>

        // Сначала пробуем парсить время в формате RFC3339
        <span class="cov8" title="1">expr.CreatedAt, err = time.Parse(time.RFC3339, createdAtStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">expr.UpdatedAt, err = time.Parse(time.RFC3339, updatedAtStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;expr, nil</span>
}

// UpdateExpressionStatus обновляет статус выражения
func UpdateExpressionStatus(id int64, status string) error <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        _, err := DB.Exec(
                "UPDATE expressions SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
                status, id,
        )
        return err
}</span>

// SetExpressionResult устанавливает результат выражения
func SetExpressionResult(id int64, result float64) error <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        _, err := DB.Exec(
                `UPDATE expressions 
         SET result = ?, status = ?, updated_at = CURRENT_TIMESTAMP 
         WHERE id = ?`,
                result, StatusCompleted, id,
        )
        return err
}</span>

// SetExpressionError устанавливает ошибку для выражения
func SetExpressionError(id int64, errorMessage string) error <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        _, err := DB.Exec(
                `UPDATE expressions 
         SET error_message = ?, status = ?, updated_at = CURRENT_TIMESTAMP 
         WHERE id = ?`,
                errorMessage, StatusError, id,
        )
        return err
}</span>

// GetUserExpressions получает все выражения пользователя
func GetUserExpressions(userID int64) ([]*Expression, error) <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        rows, err := DB.Query(
                `SELECT id, user_id, original_expression, status, result, 
         error_message, created_at, updated_at 
         FROM expressions 
         WHERE user_id = ? 
         ORDER BY created_at DESC`,
                userID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var expressions []*Expression

        for rows.Next() </span><span class="cov8" title="1">{
                var expr Expression
                var createdAtStr, updatedAtStr string
                var result sql.NullFloat64
                var errorMessage sql.NullString

                err := rows.Scan(
                        &amp;expr.ID, &amp;expr.UserID, &amp;expr.Expression, &amp;expr.Status,
                        &amp;result, &amp;errorMessage, &amp;createdAtStr, &amp;updatedAtStr,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if result.Valid </span><span class="cov0" title="0">{
                        val := result.Float64
                        expr.Result = &amp;val
                }</span>

                <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov0" title="0">{
                        val := errorMessage.String
                        expr.ErrorMessage = &amp;val
                }</span>

                // Сначала пробуем парсить время в формате RFC3339
                <span class="cov8" title="1">expr.CreatedAt, err = time.Parse(time.RFC3339, createdAtStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Аналогично для UpdatedAt
                <span class="cov8" title="1">expr.UpdatedAt, err = time.Parse(time.RFC3339, updatedAtStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">expressions = append(expressions, &amp;expr)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return expressions, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package db

import (
        "database/sql"
        "errors"
        "time"
)

var (
        ErrOperationNotFound = errors.New("operation not found")
)

// CreateOperation создает новую операцию в базе данных
func CreateOperation(expressionID int64, parentOpID *int64, operator string,
        leftValue, rightValue *float64, isRoot bool, childPosition *string, status string) (*Operation, error) <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()

        query := `
                INSERT INTO operations 
                (expression_id, parent_operation_id, child_position, left_value, right_value,
                operator, status, is_root_expression) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        res, err := DB.Exec(
                query,
                expressionID, parentOpID, childPosition, leftValue, rightValue,
                operator, status, isRoot,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Возвращаем созданную операцию
        <span class="cov8" title="1">id, err := res.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Operation{
                ID:               id,
                ExpressionID:     expressionID,
                ParentOpID:       parentOpID,
                ChildPosition:    childPosition,
                LeftValue:        leftValue,
                RightValue:       rightValue,
                Operator:         operator,
                Status:           status,
                IsRootExpression: isRoot,
                CreatedAt:        time.Now(),
                UpdatedAt:        time.Now(),
        }, nil</span>
}

// GetOperationByID получает операцию по ID
func GetOperationByID(id int64) (*Operation, error) <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        var op Operation
        var createdAtStr, updatedAtStr string
        var parentOpID sql.NullInt64
        var leftValue, rightValue, result sql.NullFloat64
        var childPosition sql.NullString
        var errorMessage sql.NullString
        var isRoot bool // Изменили тип на bool, так как SQLite хранит это поле как boolean

        err := DB.QueryRow(
                `SELECT id, expression_id, parent_operation_id, child_position, left_value, right_value,
                operator, status, result, error_message, is_root_expression, created_at, updated_at
                FROM operations WHERE id = ?`,
                id,
        ).Scan(
                &amp;op.ID, &amp;op.ExpressionID, &amp;parentOpID, &amp;childPosition, &amp;leftValue, &amp;rightValue,
                &amp;op.Operator, &amp;op.Status, &amp;result, &amp;errorMessage, &amp;isRoot, &amp;createdAtStr, &amp;updatedAtStr,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrOperationNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Обрабатываем нулевые поля
        <span class="cov8" title="1">if parentOpID.Valid </span><span class="cov0" title="0">{
                val := parentOpID.Int64
                op.ParentOpID = &amp;val
        }</span>

        <span class="cov8" title="1">if leftValue.Valid </span><span class="cov8" title="1">{
                val := leftValue.Float64
                op.LeftValue = &amp;val
        }</span>

        <span class="cov8" title="1">if rightValue.Valid </span><span class="cov8" title="1">{
                val := rightValue.Float64
                op.RightValue = &amp;val
        }</span>

        // Обрабатываем позицию относительно родителя
        <span class="cov8" title="1">if childPosition.Valid </span><span class="cov0" title="0">{
                val := childPosition.String
                op.ChildPosition = &amp;val
        }</span>

        <span class="cov8" title="1">if result.Valid </span><span class="cov8" title="1">{
                val := result.Float64
                op.Result = &amp;val
        }</span>

        <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov8" title="1">{
                val := errorMessage.String
                op.ErrorMessage = &amp;val
        }</span>

        <span class="cov8" title="1">op.IsRootExpression = isRoot

        // Парсим временные метки в формате RFC3339
        op.CreatedAt, err = time.Parse(time.RFC3339, createdAtStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">op.UpdatedAt, err = time.Parse(time.RFC3339, updatedAtStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;op, nil</span>
}

// GetOperationsByExpressionID получает все операции для выражения
func GetOperationsByExpressionID(expressionID int64) ([]*Operation, error) <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        rows, err := DB.Query(
                `SELECT id, expression_id, parent_operation_id, child_position, left_value, right_value,
                operator, status, result, error_message, is_root_expression, created_at, updated_at
                FROM operations WHERE expression_id = ?`,
                expressionID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var operations []*Operation

        for rows.Next() </span><span class="cov8" title="1">{
                var op Operation
                var createdAtStr, updatedAtStr string
                var parentOpID sql.NullInt64
                var childPosition sql.NullString
                var leftValue, rightValue, result sql.NullFloat64
                var errorMessage sql.NullString
                var isRoot bool

                err := rows.Scan(
                        &amp;op.ID, &amp;op.ExpressionID, &amp;parentOpID, &amp;childPosition, &amp;leftValue, &amp;rightValue,
                        &amp;op.Operator, &amp;op.Status, &amp;result, &amp;errorMessage, &amp;isRoot, &amp;createdAtStr, &amp;updatedAtStr,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Handle nullable fields
                <span class="cov8" title="1">if parentOpID.Valid </span><span class="cov8" title="1">{
                        val := parentOpID.Int64
                        op.ParentOpID = &amp;val
                }</span>

                <span class="cov8" title="1">if leftValue.Valid </span><span class="cov8" title="1">{
                        val := leftValue.Float64
                        op.LeftValue = &amp;val
                }</span>

                <span class="cov8" title="1">if rightValue.Valid </span><span class="cov8" title="1">{
                        val := rightValue.Float64
                        op.RightValue = &amp;val
                }</span>

                <span class="cov8" title="1">if childPosition.Valid </span><span class="cov8" title="1">{
                        val := childPosition.String
                        op.ChildPosition = &amp;val
                }</span>

                <span class="cov8" title="1">if result.Valid </span><span class="cov0" title="0">{
                        val := result.Float64
                        op.Result = &amp;val
                }</span>

                <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov0" title="0">{
                        val := errorMessage.String
                        op.ErrorMessage = &amp;val
                }</span>

                // Значение уже имеет тип bool, просто присваиваем
                <span class="cov8" title="1">op.IsRootExpression = isRoot

                // Парсим временные метки в формате RFC3339
                op.CreatedAt, err = time.Parse(time.RFC3339, createdAtStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">op.UpdatedAt, err = time.Parse(time.RFC3339, updatedAtStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">operations = append(operations, &amp;op)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return operations, nil</span>
}

// UpdateOperationStatus обновляет статус операции
func UpdateOperationStatus(id int64, status string) error <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        _, err := DB.Exec(
                "UPDATE operations SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
                status, id,
        )
        return err
}</span>

// SetOperationResult устанавливает только результат операции, не изменяя статус
func SetOperationResult(id int64, result float64) error <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()

        // Обновляем только значение результата
        _, err := DB.Exec(
                "UPDATE operations SET result = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
                result, id,
        )
        return err
}</span>

// OperationInfo содержит основную информацию об операции
type OperationInfo struct {
        ID               int64
        ExpressionID     int64
        IsRootExpression bool
        Status           string
}

// SetOperationError устанавливает ошибку для операции и обновляет её статус
func SetOperationError(operationID int64, errorMsg string) error <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()

        _, err := DB.Exec(
                "UPDATE operations SET status = ?, error_message = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
                StatusError, errorMsg, operationID,
        )
        return err
}</span>

// GetOperationInfo получает основную информацию об операции
func GetOperationInfo(id int64) (*OperationInfo, error) <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()

        var info OperationInfo
        err := DB.QueryRow(
                "SELECT id, expression_id, is_root_expression, status FROM operations WHERE id = ?",
                id,
        ).Scan(&amp;info.ID, &amp;info.ExpressionID, &amp;info.IsRootExpression, &amp;info.Status)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;info, nil</span>
}

// CancelOperationsByExpressionID отменяет все операции по expressionID
func CancelOperationsByExpressionID(expressionID int64) error <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()

        _, err := DB.Exec(
                "UPDATE operations SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE expression_id = ?",
                StatusCanceled, expressionID,
        )
        return err
}</span>

// GetReadyOperation получает одну операцию, которая готова к обработке
func GetReadyOperation() (*Operation, error) <span class="cov8" title="1">{
        // Используем write lock, т.к. сразу после получения операции мы обновим её статус
        DbMutex.Lock()
        defer DbMutex.Unlock()

        var op Operation
        var createdAtStr, updatedAtStr string
        var parentOpID sql.NullInt64
        var childPosition sql.NullString
        var leftValue, rightValue, result sql.NullFloat64
        var errorMessage sql.NullString
        var isRoot bool

        err := DB.QueryRow(
                `SELECT id, expression_id, parent_operation_id, child_position, left_value, right_value,
                operator, status, result, error_message, is_root_expression, created_at, updated_at
                FROM operations 
                WHERE status = ? LIMIT 1`,
                StatusReady,
        ).Scan(
                &amp;op.ID, &amp;op.ExpressionID, &amp;parentOpID, &amp;childPosition, &amp;leftValue, &amp;rightValue,
                &amp;op.Operator, &amp;op.Status, &amp;result, &amp;errorMessage, &amp;isRoot, &amp;createdAtStr, &amp;updatedAtStr,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil // Нет готовых операций
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Handle nullable fields
        <span class="cov8" title="1">if parentOpID.Valid </span><span class="cov0" title="0">{
                val := parentOpID.Int64
                op.ParentOpID = &amp;val
        }</span>

        <span class="cov8" title="1">if leftValue.Valid </span><span class="cov8" title="1">{
                val := leftValue.Float64
                op.LeftValue = &amp;val
        }</span>

        <span class="cov8" title="1">if rightValue.Valid </span><span class="cov8" title="1">{
                val := rightValue.Float64
                op.RightValue = &amp;val
        }</span>

        <span class="cov8" title="1">if childPosition.Valid </span><span class="cov0" title="0">{
                val := childPosition.String
                op.ChildPosition = &amp;val
        }</span>

        <span class="cov8" title="1">if result.Valid </span><span class="cov0" title="0">{
                val := result.Float64
                op.Result = &amp;val
        }</span>

        <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov0" title="0">{
                val := errorMessage.String
                op.ErrorMessage = &amp;val
        }</span>

        <span class="cov8" title="1">op.IsRootExpression = isRoot

        // Parse timestamps
        op.CreatedAt, err = time.Parse(time.RFC3339, createdAtStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Аналогично для UpdatedAt
        <span class="cov8" title="1">op.UpdatedAt, err = time.Parse(time.RFC3339, updatedAtStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;op, nil</span>
}

// UpdateOperation обновляет операцию в базе данных
func UpdateOperation(op *Operation) error <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        _, err := DB.Exec(
                `UPDATE operations 
                 SET parent_operation_id = ?, child_position = ?, left_value = ?, right_value = ?, 
                 operator = ?, status = ?, result = ?, 
                 error_message = ?, is_root_expression = ?
                 WHERE id = ?`,
                op.ParentOpID, op.ChildPosition, op.LeftValue, op.RightValue,
                op.Operator, op.Status, op.Result, op.ErrorMessage,
                op.IsRootExpression, op.ID,
        )

        return err
}</span>

// UpdateOperationLeftValue устанавливает левый операнд операции
func UpdateOperationLeftValue(operationID int64, value float64) error <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()

        _, err := DB.Exec(
                `UPDATE operations 
                 SET left_value = ?, updated_at = CURRENT_TIMESTAMP 
                 WHERE id = ?`,
                value, operationID,
        )
        return err
}</span>

// UpdateOperationRightValue устанавливает правый операнд операции
func UpdateOperationRightValue(operationID int64, value float64) error <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()

        _, err := DB.Exec(
                `UPDATE operations 
                 SET right_value = ?, updated_at = CURRENT_TIMESTAMP 
                 WHERE id = ?`,
                value, operationID,
        )
        return err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package db

import (
        "database/sql"
        "errors"
        "time"

        "golang.org/x/crypto/bcrypt"
)

// Ошибки
var (
        ErrUserNotFound       = errors.New("user not found")
        ErrUserAlreadyExists  = errors.New("user already exists")
        ErrInvalidCredentials = errors.New("invalid credentials")
)

// CreateUser создает нового пользователя в базе данных
func CreateUser(login, password string) (*User, error) <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        // Проверяем, что пользователь уже существует
        var count int
        err := DB.QueryRow("SELECT COUNT(*) FROM users WHERE login = ?", login).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if count &gt; 0 </span><span class="cov8" title="1">{
                return nil, ErrUserAlreadyExists
        }</span>

        // Хешируем пароль
        <span class="cov8" title="1">passwordHash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Добавляем нового пользователя
        <span class="cov8" title="1">result, err := DB.Exec(
                "INSERT INTO users (login, password_hash) VALUES (?, ?)",
                login, string(passwordHash),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;User{
                ID:           id,
                Login:        login,
                PasswordHash: string(passwordHash),
                CreatedAt:    time.Now(),
        }, nil</span>
}

// GetUserByID получает пользователя по ID
func GetUserByID(id int64) (*User, error) <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        var user User
        var createdAtStr string

        err := DB.QueryRow(
                "SELECT id, login, password_hash, created_at FROM users WHERE id = ?",
                id,
        ).Scan(&amp;user.ID, &amp;user.Login, &amp;user.PasswordHash, &amp;createdAtStr)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">user.CreatedAt, err = time.Parse(time.RFC3339, createdAtStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;user, nil</span>
}

// GetUserByLogin получает пользователя по логину
func GetUserByLogin(login string) (*User, error) <span class="cov8" title="1">{
        DbMutex.Lock()
        defer DbMutex.Unlock()
        var user User
        var createdAtStr string

        err := DB.QueryRow(
                "SELECT id, login, password_hash, created_at FROM users WHERE login = ?",
                login,
        ).Scan(&amp;user.ID, &amp;user.Login, &amp;user.PasswordHash, &amp;createdAtStr)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">user.CreatedAt, err = time.Parse(time.RFC3339, createdAtStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;user, nil</span>
}

// AuthenticateUser проверяет, действительны ли предоставленные учетные данные
func AuthenticateUser(login, password string) (*User, error) <span class="cov8" title="1">{
        // Здесь мьютекс не нужен, т.к. мы вызываем GetUserByLogin, где уже есть мьютекс
        user, err := GetUserByLogin(login)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Сравниваем хешированный пароль с предоставленным паролем
        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))
        if err != nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidCredentials
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package grpc

import (
        "context"
        "errors"
        "parallel-calculator/internal/logger"
        "parallel-calculator/proto"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

// GRPCTaskClient представляет gRPC клиент для взаимодействия с оркестратором
type GRPCTaskClient struct {
        conn   *grpc.ClientConn
        client proto.TaskServiceClient
}

// NewGRPCTaskClient создает новый gRPC клиент для взаимодействия с оркестратором
func NewGRPCTaskClient(address string) (*GRPCTaskClient, error) <span class="cov8" title="1">{
        // Устанавливаем соединение с сервером, используя незащищенный канал (для простоты)
        // В продакшене рекомендуется использовать TLS
        conn, err := grpc.Dial(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Создаем клиент
        <span class="cov8" title="1">client := proto.NewTaskServiceClient(conn)

        return &amp;GRPCTaskClient{
                conn:   conn,
                client: client,
        }, nil</span>
}

// Close закрывает соединение с сервером
func (c *GRPCTaskClient) Close() error <span class="cov8" title="1">{
        if c.conn != nil </span><span class="cov8" title="1">{
                return c.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetTask запрашивает задачу от оркестратора
// Возвращает структуру Task для агента
func (c *GRPCTaskClient) GetTask() (*Task, error) <span class="cov8" title="1">{
        logger.INFO.Println("Отправка запроса на получение задачи через gRPC")

        // Создаем контекст с таймаутом
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Отправляем запрос
        resp, err := c.client.GetTask(ctx, &amp;proto.GetTaskRequest{})
        if err != nil </span><span class="cov0" title="0">{
                logger.ERROR.Println("Ошибка при получении задачи: ", err)
                return nil, err
        }</span>

        // Если задач нет, возвращаем nil
        <span class="cov8" title="1">if !resp.HasTask </span><span class="cov0" title="0">{
                logger.INFO.Println("Нет доступных задач")
                return nil, nil
        }</span>

        // Преобразуем ответ в структуру Task
        <span class="cov8" title="1">task := &amp;Task{
                ID:            resp.Id,
                LeftValue:     resp.LeftValue,
                RightValue:    resp.RightValue,
                Operator:      resp.Operator,
                OperationTime: time.Duration(resp.OperationTimeNs),
        }

        logger.INFO.Println("Получена задача: ", task)
        return task, nil</span>
}

// SendTaskResult отправляет результат выполнения задачи оркестратору
func (c *GRPCTaskClient) SendTaskResult(taskResult TaskResult) error <span class="cov8" title="1">{
        logger.INFO.Println("Отправка результата задачи через gRPC: ", taskResult)

        // Создаем контекст с таймаутом
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Отправляем запрос
        resp, err := c.client.SendTaskResult(ctx, &amp;proto.TaskResultRequest{
                Id:     taskResult.ID,
                Result: taskResult.Result,
                Error:  taskResult.Error,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.ERROR.Println("Ошибка при отправке результата задачи: ", err)
                return err
        }</span>

        // Проверяем успешность операции
        <span class="cov8" title="1">if !resp.Success </span><span class="cov0" title="0">{
                logger.ERROR.Println("Сервер сообщил об ошибке: ", resp.Error)
                return errors.New(resp.Error)
        }</span>

        <span class="cov8" title="1">logger.INFO.Println("Результат задачи успешно отправлен")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package grpc

import (
        "context"
        "net"
        "parallel-calculator/internal/db"
        "parallel-calculator/internal/logger"
        "parallel-calculator/internal/orchestrator"
        "parallel-calculator/proto"
        "time"

        "google.golang.org/grpc"
)

// OrchestratorService имплементирует TaskServiceServer из сгенерированного кода
type OrchestratorService struct {
        proto.UnimplementedTaskServiceServer
}

// GetTask возвращает задачу для обработки агентом
func (s *OrchestratorService) GetTask(ctx context.Context, req *proto.GetTaskRequest) (*proto.GetTaskResponse, error) <span class="cov8" title="1">{
        logger.INFO.Println("gRPC: Запрос на получение задачи от агента")
        // Получаем одну готовую к обработке операцию из БД
        readyOp, err := db.GetReadyOperation()
        if err != nil </span><span class="cov0" title="0">{
                logger.LogERROR("Ошибка получения операции: " + err.Error())
                return &amp;proto.GetTaskResponse{
                        HasTask: false,
                }, nil
        }</span>

        // Проверяем, есть ли операция
        <span class="cov8" title="1">if readyOp == nil </span><span class="cov8" title="1">{
                return &amp;proto.GetTaskResponse{
                        HasTask: false,
                }, nil
        }</span>

        // Обновляем статус операции на "обрабатывается"
        <span class="cov8" title="1">err = db.UpdateOperationStatus(readyOp.ID, db.StatusProcessing)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogERROR("Ошибка обновления статуса операции: " + err.Error())
                return &amp;proto.GetTaskResponse{
                        HasTask: false,
                }, nil
        }</span>

        // Создаем ответ с задачей
        // Проверяем значения LeftValue и RightValue на nil
        <span class="cov8" title="1">var leftVal, rightVal float64
        if readyOp.LeftValue != nil </span><span class="cov8" title="1">{
                leftVal = *readyOp.LeftValue
        }</span>
        <span class="cov8" title="1">if readyOp.RightValue != nil </span><span class="cov8" title="1">{
                rightVal = *readyOp.RightValue
        }</span>

        // Определяем время операции на основе сложности оператора
        <span class="cov8" title="1">var opTime time.Duration
        switch readyOp.Operator </span>{
        case "+", "-":<span class="cov8" title="1">
                opTime = 1 * time.Second</span>
        case "*":<span class="cov8" title="1">
                opTime = 2 * time.Second</span>
        case "/":<span class="cov0" title="0">
                opTime = 3 * time.Second</span>
        default:<span class="cov0" title="0">
                opTime = 1 * time.Second</span>
        }

        <span class="cov8" title="1">return &amp;proto.GetTaskResponse{
                HasTask:         true,
                Id:              uint32(readyOp.ID),
                LeftValue:       leftVal,
                RightValue:      rightVal,
                Operator:        readyOp.Operator,
                OperationTimeNs: int64(opTime),
        }, nil</span>
}

// SendTaskResult обрабатывает результат выполнения задачи
func (s *OrchestratorService) SendTaskResult(ctx context.Context, req *proto.TaskResultRequest) (*proto.TaskResultResponse, error) <span class="cov8" title="1">{
        logger.INFO.Printf("gRPC: Получен результат задачи ID=%d", req.Id)
        // Преобразуем запрос в структуру TaskResult для оркестратора
        taskResult := orchestrator.TaskResult{
                ID:     int64(req.Id),
                Result: req.Result,
                Error:  req.Error,
        }

        // Обрабатываем результат через оркестратор
        err := orchestrator.ProcessExpressionResult(taskResult)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogERROR("Ошибка обработки результата: " + err.Error())
                return &amp;proto.TaskResultResponse{
                        Success: false,
                        Error:   err.Error(),
                }, nil
        }</span>

        <span class="cov8" title="1">return &amp;proto.TaskResultResponse{
                Success: true,
                Error:   "",
        }, nil</span>
}

// StartGRPCServer запускает gRPC сервер на указанном адресе и возвращает экземпляр сервера
func StartGRPCServer(address string) (*grpc.Server, error) <span class="cov8" title="1">{
        // Создаем TCP слушатель
        lis, err := net.Listen("tcp", address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Создаем новый gRPC сервер
        <span class="cov8" title="1">s := grpc.NewServer()

        // Регистрируем наш сервис на сервере
        proto.RegisterTaskServiceServer(s, &amp;OrchestratorService{})

        // Запускаем сервер
        logger.INFO.Printf("gRPC оркестратор запущен на %s", address)

        // Запуск в горутине с возможностью graceful shutdown
        go func() </span><span class="cov8" title="1">{
                if err := s.Serve(lis); err != nil &amp;&amp; err != grpc.ErrServerStopped </span><span class="cov0" title="0">{
                        logger.ERROR.Fatalf("Ошибка запуска gRPC оркестратора: %v", err)
                }</span>
        }()

        <span class="cov8" title="1">return s, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package logger

import (
        "log"
        "os"
        "parallel-calculator/internal/config"
        "sync"
)

var (
        fileMutex sync.Mutex
        INFO      *log.Logger
        ERROR     *log.Logger
        logFile   *os.File
)

func LogINFO(s string) <span class="cov0" title="0">{
        if INFO == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">INFO.Println(s)</span>
}

func LogERROR(s string) <span class="cov0" title="0">{
        if ERROR == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ERROR.Println(s)</span>
}

type lockedFile struct {
        file *os.File
}

func (lf *lockedFile) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        fileMutex.Lock()
        defer fileMutex.Unlock()
        return lf.file.Write(p)
}</span>

func InitAgentLogger() <span class="cov0" title="0">{
        config := config.AppConfig

        if config.AgentLogFilePath == "" </span><span class="cov0" title="0">{
                log.Fatal("agent log file path not set")
        }</span>

        <span class="cov0" title="0">logFile, err := os.OpenFile(config.AgentLogFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to open log file: %v. We will use standard output", err)
                INFO = log.New(os.Stdout, "INFO: ", log.Ldate|log.Ltime|log.Lshortfile)
                ERROR = log.New(os.Stdout, "ERROR: ", log.Ldate|log.Ltime|log.Lshortfile)
                return
        }</span>

        <span class="cov0" title="0">writer := &amp;lockedFile{file: logFile}
        INFO = log.New(writer, "INFO: ", log.Ldate|log.Ltime|log.Lshortfile)
        ERROR = log.New(writer, "ERROR: ", log.Ldate|log.Ltime|log.Lshortfile)</span>
}

func InitClientLogger() <span class="cov0" title="0">{
        config := config.AppConfig

        if config.ClientLogFilePath == "" </span><span class="cov0" title="0">{
                log.Fatal("client log file path not set")
        }</span>

        <span class="cov0" title="0">logFile, err := os.OpenFile(config.ClientLogFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to open log file: %v. We will use standard output", err)
                INFO = log.New(os.Stdout, "INFO: ", log.Ldate|log.Ltime|log.Lshortfile)
                ERROR = log.New(os.Stdout, "ERROR: ", log.Ldate|log.Ltime|log.Lshortfile)
                return
        }</span>

        <span class="cov0" title="0">writer := &amp;lockedFile{file: logFile}
        INFO = log.New(writer, "INFO: ", log.Ldate|log.Ltime|log.Lshortfile)
        ERROR = log.New(writer, "ERROR: ", log.Ldate|log.Ltime|log.Lshortfile)</span>
}

func CloseLogger() <span class="cov0" title="0">{
        if logFile != nil </span><span class="cov0" title="0">{
                logFile.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package orchestrator

import (
        "database/sql"
        "fmt"
        "go/ast"
        "go/token"
        "parallel-calculator/internal/db"
        "parallel-calculator/internal/logger"
        "strconv"
)

// Статусы для выражений и операций
const (
        StatusPending    = "pending"
        StatusReady      = "ready"
        StatusProcessing = "processing"
        StatusCompleted  = "completed"
        StatusError      = "error"
        StatusCanceled   = "canceled"
)

// ErrInvalidExpression ошибка для случая неверного выражения
var ErrInvalidExpression = fmt.Errorf("invalid expression")

// ParseAST парсит AST и создает операции в базе данных
// Единый метод для валидации и создания операций в БД
func ParseAST(expressionID int64, node ast.Node) error <span class="cov8" title="1">{
        // Первый проход: проверка корректности без генерации ID
        if err := validateAST(node); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Открываем транзакцию для второго прохода
        <span class="cov8" title="1">tx, err := db.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Второй проход: сохранение в БД с транзакцией
        <span class="cov8" title="1">if _, err := saveASTToDB(tx, expressionID, node, nil, "nil"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Фиксируем транзакцию
        <span class="cov8" title="1">return tx.Commit()</span>
}

// validateAST проверяет корректность AST без сохранения в БД
// Вспомогательная функция для первого прохода
func validateAST(node ast.Node) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return ErrInvalidExpression
        }</span>

        <span class="cov8" title="1">switch n := node.(type) </span>{
        case *ast.BinaryExpr:<span class="cov8" title="1">
                // Проверяем оператор
                switch n.Op </span>{
                case token.ADD, token.SUB, token.MUL, token.QUO:<span class="cov8" title="1"></span>
                        // Поддерживаемые операторы
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unsupported operator: %s", n.Op)</span>
                }

                // Рекурсивно проверяем левую и правую части
                <span class="cov8" title="1">if err := validateAST(n.X); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := validateAST(n.Y); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>

        case *ast.ParenExpr:<span class="cov8" title="1">
                // Проверяем содержимое скобок
                return validateAST(n.X)</span>

        case *ast.BasicLit:<span class="cov8" title="1">
                // Проверяем, что литерал - число
                if n.Kind != token.INT &amp;&amp; n.Kind != token.FLOAT </span><span class="cov0" title="0">{
                        return fmt.Errorf("unsupported literal type: %s", n.Kind)
                }</span>

                // Проверяем, что число можно распарсить
                <span class="cov8" title="1">_, err := strconv.ParseFloat(n.Value, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid numeric value: %s - %v", n.Value, err)
                }</span>
                <span class="cov8" title="1">return nil</span>

        default:<span class="cov0" title="0">
                logger.LogINFO(fmt.Sprintf("Неизвестный тип узла AST: %T", n))
                return fmt.Errorf("unsupported expression element: %T", n)</span>
        }
}

// saveASTToDB сохраняет AST в базу данных, возвращает ID корневой операции
func saveASTToDB(tx *sql.Tx, expressionID int64, node ast.Node, parentOpID *int64, childPosition string) (int64, error) <span class="cov8" title="1">{
        switch n := node.(type) </span>{
        case *ast.BasicLit:<span class="cov8" title="1">
                value, _ := strconv.ParseFloat(n.Value, 64)

                // Это одиночное число как корневое выражение
                err := db.UpdateExpressionStatus(
                        expressionID, StatusCompleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">err = db.SetExpressionResult(expressionID, value)
                return 0, err</span>

        case *ast.ParenExpr:<span class="cov8" title="1">
                return saveASTToDB(tx, expressionID, n.X, parentOpID, childPosition)</span>

        case *ast.BinaryExpr:<span class="cov8" title="1">
                // Создаем операцию для выражения
                var (
                        leftVal, rightVal *float64
                        childPos          *string
                )

                if parentOpID != nil </span><span class="cov8" title="1">{
                        childPos = &amp;childPosition
                }</span>

                // Проверяем, являются ли операнды литералами
                <span class="cov8" title="1">if value, ok := IsLiteralOnly(n.X); ok </span><span class="cov8" title="1">{
                        leftVal = &amp;value
                }</span>
                <span class="cov8" title="1">if value, ok := IsLiteralOnly(n.Y); ok </span><span class="cov8" title="1">{
                        rightVal = &amp;value
                }</span>

                // Определяем начальный статус
                <span class="cov8" title="1">status := StatusPending
                if leftVal != nil &amp;&amp; rightVal != nil </span><span class="cov8" title="1">{
                        status = StatusReady
                }</span>

                // Создаем запись операции
                <span class="cov8" title="1">op, err := db.CreateOperation(
                        expressionID, parentOpID, n.Op.String(),
                        leftVal, rightVal, parentOpID == nil, childPos, status,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                // Обрабатываем нелитеральные операнды
                <span class="cov8" title="1">if leftVal == nil </span><span class="cov8" title="1">{
                        if _, err := saveASTToDB(tx, expressionID, n.X, &amp;op.ID, "left"); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }

                <span class="cov8" title="1">if rightVal == nil </span><span class="cov8" title="1">{
                        if _, err := saveASTToDB(tx, expressionID, n.Y, &amp;op.ID, "right"); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }

                <span class="cov8" title="1">return op.ID, nil</span>

        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unsupported node type: %T", node)</span>
        }
}

// IsLiteralOnly проверяет, является ли узел AST литералом и возвращает его значение
func IsLiteralOnly(node ast.Node) (float64, bool) <span class="cov8" title="1">{
        switch n := node.(type) </span>{
        case *ast.BasicLit:<span class="cov8" title="1">
                value, err := strconv.ParseFloat(n.Value, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>
                <span class="cov8" title="1">return value, true</span>
        case *ast.ParenExpr:<span class="cov8" title="1">
                return IsLiteralOnly(n.X)</span>
        default:<span class="cov8" title="1">
                return 0, false</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package orchestrator

import (
        "errors"
        "fmt"
        "net/http"
        "parallel-calculator/internal/auth"
        "parallel-calculator/internal/db"
)

// GetUserIDFromRequest извлекает ID пользователя из запроса с JWT-токеном
func GetUserIDFromRequest(r *http.Request) (int64, error) <span class="cov8" title="1">{
        // Получаем claims из контекста (добавленные middleware auth)
        claims, ok := auth.GetUserFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                return 0, errors.New("не удалось получить информацию о пользователе")
        }</span>

        <span class="cov8" title="1">return claims.UserID, nil</span>
}

// CreateExpressionInDB создает новое выражение в базе данных
func CreateExpressionInDB(userID int64, expressionStr string) (*db.Expression, error) <span class="cov8" title="1">{
        // Создаем запись выражения в БД
        expr, err := db.CreateExpression(userID, expressionStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка создания выражения в БД: %w", err)
        }</span>

        <span class="cov8" title="1">return expr, nil</span>
}

// CreateOperationInDB создает операцию в базе данных
func CreateOperationInDB(
        expressionID int64,
        parentOpID *int64,
        operator string,
        leftValue, rightValue *float64,
        isRoot bool,
        childPosition *string,
        status string) (*db.Operation, error) <span class="cov8" title="1">{

        // Создаем операцию в БД
        op, err := db.CreateOperation(
                expressionID,
                parentOpID,
                operator,
                leftValue, rightValue,
                isRoot,
                childPosition,
                status)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка создания операции в БД: %w", err)
        }</span>

        <span class="cov8" title="1">return op, nil</span>
}

// UpdateOperationStatusInDB обновляет статус операции в БД
func UpdateOperationStatusInDB(operationID int64, status string) error <span class="cov8" title="1">{
        return db.UpdateOperationStatus(operationID, status)
}</span>

// SetOperationResultInDB устанавливает результат операции
func SetOperationResultInDB(operationID int64, result float64) error <span class="cov8" title="1">{
        // Вызываем базовую функцию для установки результата операции
        err := db.SetOperationResult(operationID, result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Проверяем, является ли это корневой операцией
        <span class="cov8" title="1">operationInfo, err := db.GetOperationInfo(operationID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Если это корневая операция, обновляем результат выражения
        <span class="cov8" title="1">if operationInfo.IsRootExpression &amp;&amp; operationInfo.ExpressionID &gt; 0 </span><span class="cov8" title="1">{
                return db.SetExpressionResult(operationInfo.ExpressionID, result)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// HandleOperationErrorInDB обрабатывает ошибку операции
func HandleOperationErrorInDB(operationID int64, errorMsg string) error <span class="cov8" title="1">{
        // Получаем операцию, чтобы узнать выражение
        op, err := db.GetOperationByID(operationID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при получении операции: %w", err)
        }</span>

        // Устанавливаем ошибку для операции
        <span class="cov8" title="1">err = db.SetOperationError(operationID, errorMsg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при установке ошибки операции: %w", err)
        }</span>

        // Устанавливаем ошибку для выражения
        <span class="cov8" title="1">err = db.SetExpressionError(op.ExpressionID, errorMsg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при установке ошибки выражения: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// HandleOperationErrorWithCancellation обрабатывает ошибку операции и отменяет все связанные операции
func HandleOperationErrorWithCancellation(operationID int64, errorMsg string) error <span class="cov8" title="1">{
        // Сначала получаем операцию, чтобы узнать выражение
        op, err := db.GetOperationByID(operationID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при получении операции: %w", err)
        }</span>

        // Устанавливаем ошибку для выражения
        <span class="cov8" title="1">err = db.SetExpressionError(op.ExpressionID, errorMsg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при установке ошибки выражения: %w", err)
        }</span>

        // Отменяем все остальные операции выражения
        <span class="cov8" title="1">err = db.CancelOperationsByExpressionID(op.ExpressionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при отмене операций: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetExpressionsByUserID получает все выражения пользователя
func GetExpressionsByUserID(userID int64) ([]*db.Expression, error) <span class="cov8" title="1">{
        return db.GetUserExpressions(userID)
}</span>

// GetExpressionByID получает выражение по ID
func GetExpressionByID(id int64) (*db.Expression, error) <span class="cov8" title="1">{
        expr, err := db.GetExpressionByID(id)
        if err != nil </span><span class="cov8" title="1">{
                // Преобразуем ошибку db.ErrExpressionNotFound в orchestrator.ErrExpressionNotFound
                if err == db.ErrExpressionNotFound </span><span class="cov8" title="1">{
                        return nil, ErrExpressionNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return expr, nil</span>
}

// UpdateParentOperation обновляет аргументы родительской операции
func UpdateParentOperation(op *db.Operation, result float64) error <span class="cov8" title="1">{
        if op.ParentOpID == nil || op.ChildPosition == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation has no parent or position")
        }</span>

        // Обновляем соответствующий аргумент в родительской операции
        <span class="cov8" title="1">switch *op.ChildPosition </span>{
        case "left":<span class="cov8" title="1">
                // Обновляем левый аргумент родителя
                err := db.UpdateOperationLeftValue(*op.ParentOpID, result)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ошибка при обновлении левого аргумента родителя: %w", err)
                }</span>
        case "right":<span class="cov8" title="1">
                // Обновляем правый аргумент родителя
                err := db.UpdateOperationRightValue(*op.ParentOpID, result)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ошибка при обновлении правого аргумента родителя: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("неизвестная позиция операнда: %s", *op.ChildPosition)</span>
        }

        // Проверяем, есть ли у родителя оба значения
        <span class="cov8" title="1">parentOp, err := db.GetOperationByID(*op.ParentOpID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при получении родительской операции: %w", err)
        }</span>

        <span class="cov8" title="1">if parentOp.LeftValue != nil &amp;&amp; parentOp.RightValue != nil </span><span class="cov8" title="1">{
                // Если оба аргумента заполнены, устанавливаем статус "ready"
                err = db.UpdateOperationStatus(*op.ParentOpID, db.StatusReady)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ошибка при обновлении статуса родительской операции: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetReadyOperationFromDB получает одну операцию, готовую к выполнению
func GetReadyOperationFromDB() (*db.Operation, error) <span class="cov0" title="0">{
        return db.GetReadyOperation()
}</span>

// FinalizeExpression устанавливает результат выражения и обновляет его статус на "completed"
func FinalizeExpression(expressionID int64, result float64) error <span class="cov8" title="1">{
        // 1. Устанавливаем результат выражения
        err := db.SetExpressionResult(expressionID, result)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при установке результата выражения: %w", err)
        }</span>

        // 2. Обновляем статус выражения на "completed"
        <span class="cov8" title="1">err = db.UpdateExpressionStatus(expressionID, db.StatusCompleted)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при обновлении статуса выражения: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package orchestrator

import (
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "parallel-calculator/internal/auth"
        "parallel-calculator/internal/logger"
        "strconv"

        "github.com/gorilla/mux"
)

type CalculateRequest struct {
        Expression string `json:"expression"`
}

type CalculateResponse struct {
        ID int64 `json:"id"`
}

func HandleCalculate(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var request CalculateRequest
        err := json.NewDecoder(r.Body).Decode(&amp;request)
        if err != nil </span><span class="cov8" title="1">{
                logger.LogERROR(fmt.Sprintf("Failed to decode calculate request: %v", err))
                http.Error(w, "Неверный формат запроса", http.StatusUnprocessableEntity)
                return
        }</span>

        <span class="cov8" title="1">logger.LogINFO(fmt.Sprintf("Received calculate request: %v", request.Expression))

        // Получаем ID пользователя из запроса с JWT-токеном
        userID, err := GetUserIDFromToken(r)
        if err != nil </span><span class="cov8" title="1">{
                logger.LogERROR(fmt.Sprintf("Authentication error: %v", err))
                http.Error(w, "Ошибка аутентификации", http.StatusUnauthorized)
                return
        }</span>

        // Обрабатываем выражение
        <span class="cov8" title="1">id, err := ProcessExpression(request.Expression, userID)
        if err != nil </span><span class="cov8" title="1">{
                if err == ErrInvalidExpression </span><span class="cov8" title="1">{
                        logger.LogERROR(fmt.Sprintf("Invalid expression: %v", err))
                        http.Error(w, "Неверное выражение", http.StatusUnprocessableEntity)
                        return
                }</span>
                <span class="cov0" title="0">logger.LogERROR(fmt.Sprintf("Failed to process expression: %v", err))
                http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                return</span>
        }

        // Возвращаем ID выражения как он в БД
        <span class="cov8" title="1">response := CalculateResponse{
                ID: *id,
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        err = json.NewEncoder(w).Encode(response)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
}

type ExpressionResponse struct {
        ID     int64   `json:"id"`
        Status string  `json:"status"`
        Result float64 `json:"result"`
}

// GetUserIDFromToken извлекает ID пользователя из JWT-токена
func GetUserIDFromToken(r *http.Request) (int64, error) <span class="cov8" title="1">{
        // Извлекаем токен из заголовка
        tokenString, err := auth.ExtractTokenFromHeader(r)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        // Валидируем токен и получаем claims
        <span class="cov8" title="1">claims, err := auth.ValidateToken(tokenString)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return claims.UserID, nil</span>
}

func HandleGetExpressions(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")

        logger.LogINFO("Received get expressions request")

        // Получаем ID пользователя из токена
        userID, err := GetUserIDFromToken(r)
        if err != nil </span><span class="cov8" title="1">{
                logger.LogERROR(fmt.Sprintf("Authentication error: %v", err))
                http.Error(w, "Ошибка аутентификации", http.StatusUnauthorized)
                return
        }</span>

        // Получаем выражения пользователя из базы данных
        // Используем функцию-прокси вместо прямого доступа к БД
        <span class="cov8" title="1">expressions, err := GetExpressionsByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogERROR(fmt.Sprintf("Failed to get expressions: %v", err))
                http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">expressionsResponse := make([]ExpressionResponse, len(expressions))
        for i, expr := range expressions </span><span class="cov8" title="1">{
                response := ExpressionResponse{
                        ID:     expr.ID,
                        Status: expr.Status,
                }
                // Добавляем результат, если он существует
                if expr.Result != nil </span><span class="cov0" title="0">{
                        response.Result = *expr.Result
                }</span>
                <span class="cov8" title="1">expressionsResponse[i] = response</span>
        }

        <span class="cov8" title="1">err = json.NewEncoder(w).Encode(expressionsResponse)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogERROR(fmt.Sprintf("Failed to encode expressions response: %v", err))
                http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                return
        }</span>
}

func HandleGetExpressionByID(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")

        // Получаем ID пользователя из JWT-токена
        userID, err := GetUserIDFromToken(r)
        if err != nil </span><span class="cov8" title="1">{
                logger.LogERROR(fmt.Sprintf("Authentication error: %v", err))
                http.Error(w, "Ошибка аутентификации", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        idStr := vars["id"] // получаем параметр id из URL

        logger.LogINFO(fmt.Sprintf("Received get expression by id request: %v", idStr))
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov8" title="1">{
                logger.LogERROR(fmt.Sprintf("Invalid expression ID format: %v", err))
                http.Error(w, "Неверный формат ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">logger.LogINFO(fmt.Sprintf("Processing get expression by id request: %v for user: %v", id, userID))

        // Получаем выражение по ID через функцию-прокси
        expression, err := GetExpressionByID(int64(id))
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, ErrExpressionNotFound) || errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        logger.LogERROR(fmt.Sprintf("Expression not found: %v", id))
                        http.Error(w, "Выражение не найдено", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">logger.LogERROR(fmt.Sprintf("Failed to get expression by id: %v", err))
                http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                return</span>
        }

        // Проверяем, что выражение принадлежит этому пользователю
        <span class="cov8" title="1">if expression.UserID != userID </span><span class="cov0" title="0">{
                logger.LogERROR(fmt.Sprintf("Unauthorized access to expression: %v by user: %v", id, userID))
                http.Error(w, "Нет доступа к этому выражению", http.StatusForbidden)
                return
        }</span>

        <span class="cov8" title="1">expressionResponse := ExpressionResponse{
                ID:     expression.ID,
                Status: expression.Status,
        }

        // Добавляем результат только если он существует
        if expression.Result != nil </span><span class="cov0" title="0">{
                expressionResponse.Result = *expression.Result
        }</span>

        <span class="cov8" title="1">err = json.NewEncoder(w).Encode(expressionResponse)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogERROR(fmt.Sprintf("Failed to encode expression response: %v", err))
                http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                return
        }</span>
}

type TaskResult struct {
        ID     int64   `json:"id"`
        Result float64 `json:"result"`
        Error  string  `json:"error"`
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package orchestrator

import (
        "errors"
        "fmt"
        "go/ast"
        "go/parser"
        "parallel-calculator/internal/db"
        "parallel-calculator/internal/logger"
)

// Errors
var (
        ErrQueueIsEmpty            = errors.New("queue is empty")
        ErrExpressionNotFound      = errors.New("expression not found")
        ErrInvalidAST              = errors.New("invalid AST")
        ErrLiteralNotFound         = errors.New("literal not found")
        ErrParentNotFound          = errors.New("parent expression not found")
        ErrInvalidNodePosition     = errors.New("invalid node position")
        ErrInvalidChannelCondition = errors.New("invalid channel condition")
        ErrOnlyOneLiteral          = errors.New("only one literal allowed")
        ErrInvalidParentId         = errors.New("invalid parent id")
)

func CreateAST(expression string) (ast.Node, error) <span class="cov8" title="1">{
        ast, err := parser.ParseExpr(expression)
        if err != nil </span><span class="cov8" title="1">{
                logger.LogINFO(fmt.Sprintf("Error after ParseExpr: %v", err))
                return nil, ErrInvalidExpression
        }</span>
        <span class="cov8" title="1">return ast, nil</span>
}

// Обрабатывает выражение. Возвращает id и ошибку
func ProcessExpression(expr string, userID int64) (*int64, error) <span class="cov8" title="1">{
        // Добавляем выражение в базу данных
        expression, err := CreateExpressionInDB(userID, expr)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Парсим AST из выражения
        <span class="cov8" title="1">astNode, err := CreateAST(expression.Expression)

        if err != nil </span><span class="cov8" title="1">{
                // Если произошла ошибка при парсинге, устанавливаем статус ошибки в БД
                db.SetExpressionError(expression.ID, "Invalid expression syntax: "+err.Error())
                // Возвращаем ошибку недействительного выражения
                return nil, ErrInvalidExpression
        }</span>

        // Парсим AST и создаем операции в базе данных
        <span class="cov8" title="1">err = ParseAST(expression.ID, astNode)
        if err != nil </span><span class="cov0" title="0">{
                // Обновляем статус ошибки в БД
                db.SetExpressionError(expression.ID, "Error creating operations: "+err.Error())
                return &amp;expression.ID, nil
        }</span>

        <span class="cov8" title="1">return &amp;expression.ID, nil</span>
}

// ProcessExpressionResult обрабатывает результат выполнения задачи
func ProcessExpressionResult(result TaskResult) error <span class="cov8" title="1">{
        // Получаем операцию, чтобы иметь доступ к ID выражения и другим данным
        op, err := db.GetOperationByID(result.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("не удалось получить операцию: %w", err)
        }</span>

        // Теперь ID из TaskResult напрямую является ID в базе данных
        // Проверяем наличие ошибки в результате
        <span class="cov8" title="1">if result.Error != "nil" &amp;&amp; result.Error != "" </span><span class="cov8" title="1">{
                // Обрабатываем ошибку операции и отменяем все связанные операции
                err := HandleOperationErrorWithCancellation(result.ID, result.Error)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ошибка при обработке ошибки операции: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        // 1. Устанавливаем результат операции
        <span class="cov8" title="1">err = SetOperationResultInDB(result.ID, result.Result)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при установке результата операции: %w", err)
        }</span>

        // 2. Обновляем статус операции на "completed"
        <span class="cov8" title="1">err = UpdateOperationStatusInDB(result.ID, db.StatusCompleted)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при обновлении статуса операции: %w", err)
        }</span>

        // 3. Если это корневая операция выражения, обновляем результат выражения
        <span class="cov8" title="1">if op.IsRootExpression </span><span class="cov8" title="1">{
                // Обновляем результат выражения и устанавливаем статус "completed"
                err = FinalizeExpression(op.ExpressionID, result.Result)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ошибка при финализации выражения: %w", err)
                }</span>
        } else<span class="cov0" title="0"> if op.ParentOpID != nil </span><span class="cov0" title="0">{
                // 4. Если это не корневая операция, но у неё есть родитель,
                // обновляем аргументы родительской операции
                err = UpdateParentOperation(op, result.Result)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ошибка при обновлении родительской операции: %w", err)
                }</span>
        }

        // 5. Проверяем зависимости всех операций после обновления результата
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v3.21.12
// source: proto/task.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Запрос на получение задачи (пустой)
type GetTaskRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTaskRequest) Reset() <span class="cov0" title="0">{
        *x = GetTaskRequest{}
        mi := &amp;file_proto_task_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTaskRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTaskRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTaskRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_task_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTaskRequest.ProtoReflect.Descriptor instead.
func (*GetTaskRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_task_proto_rawDescGZIP(), []int{0}
}</span>

// Ответ с задачей
type GetTaskResponse struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Если нет задачи, все поля будут иметь значения по умолчанию
        HasTask         bool    `protobuf:"varint,1,opt,name=has_task,json=hasTask,proto3" json:"has_task,omitempty"` // true если задача есть, false если очередь пуста
        Id              uint32  `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
        LeftValue       float64 `protobuf:"fixed64,3,opt,name=left_value,json=leftValue,proto3" json:"left_value,omitempty"`
        RightValue      float64 `protobuf:"fixed64,4,opt,name=right_value,json=rightValue,proto3" json:"right_value,omitempty"`
        Operator        string  `protobuf:"bytes,5,opt,name=operator,proto3" json:"operator,omitempty"`
        OperationTimeNs int64   `protobuf:"varint,6,opt,name=operation_time_ns,json=operationTimeNs,proto3" json:"operation_time_ns,omitempty"` // время операции в наносекундах
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *GetTaskResponse) Reset() <span class="cov0" title="0">{
        *x = GetTaskResponse{}
        mi := &amp;file_proto_task_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTaskResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTaskResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTaskResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_task_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTaskResponse.ProtoReflect.Descriptor instead.
func (*GetTaskResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_task_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetTaskResponse) GetHasTask() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HasTask
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *GetTaskResponse) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetTaskResponse) GetLeftValue() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LeftValue
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetTaskResponse) GetRightValue() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RightValue
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetTaskResponse) GetOperator() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Operator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetTaskResponse) GetOperationTimeNs() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OperationTimeNs
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Запрос на отправку результата задачи
type TaskResultRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            uint32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Result        float64                `protobuf:"fixed64,2,opt,name=result,proto3" json:"result,omitempty"`
        Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"` // "nil" если ошибок нет
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TaskResultRequest) Reset() <span class="cov0" title="0">{
        *x = TaskResultRequest{}
        mi := &amp;file_proto_task_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TaskResultRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TaskResultRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TaskResultRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_task_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TaskResultRequest.ProtoReflect.Descriptor instead.
func (*TaskResultRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_task_proto_rawDescGZIP(), []int{2}
}</span>

func (x *TaskResultRequest) GetId() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TaskResultRequest) GetResult() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Result
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TaskResultRequest) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Ответ на отправку результата задачи
type TaskResultResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"` // пустая строка, если ошибок нет
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TaskResultResponse) Reset() <span class="cov0" title="0">{
        *x = TaskResultResponse{}
        mi := &amp;file_proto_task_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TaskResultResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TaskResultResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TaskResultResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_task_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TaskResultResponse.ProtoReflect.Descriptor instead.
func (*TaskResultResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_task_proto_rawDescGZIP(), []int{3}
}</span>

func (x *TaskResultResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TaskResultResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_proto_task_proto protoreflect.FileDescriptor

const file_proto_task_proto_rawDesc = "" +
        "\n" +
        "\x10proto/task.proto\x12\x04task\"\x10\n" +
        "\x0eGetTaskRequest\"\xc4\x01\n" +
        "\x0fGetTaskResponse\x12\x19\n" +
        "\bhas_task\x18\x01 \x01(\bR\ahasTask\x12\x0e\n" +
        "\x02id\x18\x02 \x01(\rR\x02id\x12\x1d\n" +
        "\n" +
        "left_value\x18\x03 \x01(\x01R\tleftValue\x12\x1f\n" +
        "\vright_value\x18\x04 \x01(\x01R\n" +
        "rightValue\x12\x1a\n" +
        "\boperator\x18\x05 \x01(\tR\boperator\x12*\n" +
        "\x11operation_time_ns\x18\x06 \x01(\x03R\x0foperationTimeNs\"Q\n" +
        "\x11TaskResultRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\rR\x02id\x12\x16\n" +
        "\x06result\x18\x02 \x01(\x01R\x06result\x12\x14\n" +
        "\x05error\x18\x03 \x01(\tR\x05error\"D\n" +
        "\x12TaskResultResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error2\x8a\x01\n" +
        "\vTaskService\x126\n" +
        "\aGetTask\x12\x14.task.GetTaskRequest\x1a\x15.task.GetTaskResponse\x12C\n" +
        "\x0eSendTaskResult\x12\x17.task.TaskResultRequest\x1a\x18.task.TaskResultResponseB\x1cZ\x1aparallel-calculator/proto/b\x06proto3"

var (
        file_proto_task_proto_rawDescOnce sync.Once
        file_proto_task_proto_rawDescData []byte
)

func file_proto_task_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_task_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_task_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_task_proto_rawDesc), len(file_proto_task_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_task_proto_rawDescData</span>
}

var file_proto_task_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_proto_task_proto_goTypes = []any{
        (*GetTaskRequest)(nil),     // 0: task.GetTaskRequest
        (*GetTaskResponse)(nil),    // 1: task.GetTaskResponse
        (*TaskResultRequest)(nil),  // 2: task.TaskResultRequest
        (*TaskResultResponse)(nil), // 3: task.TaskResultResponse
}
var file_proto_task_proto_depIdxs = []int32{
        0, // 0: task.TaskService.GetTask:input_type -&gt; task.GetTaskRequest
        2, // 1: task.TaskService.SendTaskResult:input_type -&gt; task.TaskResultRequest
        1, // 2: task.TaskService.GetTask:output_type -&gt; task.GetTaskResponse
        3, // 3: task.TaskService.SendTaskResult:output_type -&gt; task.TaskResultResponse
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_proto_task_proto_init() }</span>
func file_proto_task_proto_init() <span class="cov0" title="0">{
        if File_proto_task_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_task_proto_rawDesc), len(file_proto_task_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_task_proto_goTypes,
                DependencyIndexes: file_proto_task_proto_depIdxs,
                MessageInfos:      file_proto_task_proto_msgTypes,
        }.Build()
        File_proto_task_proto = out.File
        file_proto_task_proto_goTypes = nil
        file_proto_task_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: proto/task.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        TaskService_GetTask_FullMethodName        = "/task.TaskService/GetTask"
        TaskService_SendTaskResult_FullMethodName = "/task.TaskService/SendTaskResult"
)

// TaskServiceClient is the client API for TaskService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Сервис для взаимодействия оркестратора с агентами
type TaskServiceClient interface {
        // Получение задачи агентом
        GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*GetTaskResponse, error)
        // Отправка результата задачи
        SendTaskResult(ctx context.Context, in *TaskResultRequest, opts ...grpc.CallOption) (*TaskResultResponse, error)
}

type taskServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewTaskServiceClient(cc grpc.ClientConnInterface) TaskServiceClient <span class="cov0" title="0">{
        return &amp;taskServiceClient{cc}
}</span>

func (c *taskServiceClient) GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*GetTaskResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetTaskResponse)
        err := c.cc.Invoke(ctx, TaskService_GetTask_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) SendTaskResult(ctx context.Context, in *TaskResultRequest, opts ...grpc.CallOption) (*TaskResultResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(TaskResultResponse)
        err := c.cc.Invoke(ctx, TaskService_SendTaskResult_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// TaskServiceServer is the server API for TaskService service.
// All implementations must embed UnimplementedTaskServiceServer
// for forward compatibility.
//
// Сервис для взаимодействия оркестратора с агентами
type TaskServiceServer interface {
        // Получение задачи агентом
        GetTask(context.Context, *GetTaskRequest) (*GetTaskResponse, error)
        // Отправка результата задачи
        SendTaskResult(context.Context, *TaskResultRequest) (*TaskResultResponse, error)
        mustEmbedUnimplementedTaskServiceServer()
}

// UnimplementedTaskServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTaskServiceServer struct{}

func (UnimplementedTaskServiceServer) GetTask(context.Context, *GetTaskRequest) (*GetTaskResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTask not implemented")
}</span>
func (UnimplementedTaskServiceServer) SendTaskResult(context.Context, *TaskResultRequest) (*TaskResultResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SendTaskResult not implemented")
}</span>
func (UnimplementedTaskServiceServer) mustEmbedUnimplementedTaskServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedTaskServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeTaskServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskServiceServer will
// result in compilation errors.
type UnsafeTaskServiceServer interface {
        mustEmbedUnimplementedTaskServiceServer()
}

func RegisterTaskServiceServer(s grpc.ServiceRegistrar, srv TaskServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedTaskServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;TaskService_ServiceDesc, srv)</span>
}

func _TaskService_GetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTaskRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).GetTask(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_GetTask_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).GetTask(ctx, req.(*GetTaskRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_SendTaskResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(TaskResultRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).SendTaskResult(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_SendTaskResult_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).SendTaskResult(ctx, req.(*TaskResultRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// TaskService_ServiceDesc is the grpc.ServiceDesc for TaskService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "task.TaskService",
        HandlerType: (*TaskServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetTask",
                        Handler:    _TaskService_GetTask_Handler,
                },
                {
                        MethodName: "SendTaskResult",
                        Handler:    _TaskService_SendTaskResult_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/task.proto",
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
